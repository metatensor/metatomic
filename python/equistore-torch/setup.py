import os
import subprocess
import sys
import uuid

from setuptools import Extension, setup
from setuptools.command.bdist_egg import bdist_egg
from setuptools.command.build_ext import build_ext


ROOT = os.path.realpath(os.path.dirname(__file__))
EQUISTORE_CORE = os.path.realpath(os.path.join(ROOT, "..", "equistore-core"))

EQUISTORE_TORCH = os.path.join(ROOT, "..", "..", "equistore-torch")
if not os.path.exists(EQUISTORE_TORCH):
    # we are building from a sdist, which should include equistore-torch
    # sources as a tarball
    cxx_sources = os.path.join(ROOT, "equistore-torch.tar.gz")

    if not os.path.exists(cxx_sources):
        raise RuntimeError(
            "expected an 'equistore-torch.tar.gz' file containing "
            "equistore-torch C++ sources"
        )

    subprocess.run(
        ["cmake", "-E", "tar", "xf", cxx_sources],
        cwd=ROOT,
        check=True,
    )

    EQUISTORE_TORCH = os.path.join(ROOT, "equistore-torch")


class cmake_ext(build_ext):
    """Build the native library using cmake"""

    def run(self):
        import torch

        import equistore.core

        source_dir = EQUISTORE_TORCH
        build_dir = os.path.join(ROOT, "build", "cmake-build")
        install_dir = os.path.join(os.path.realpath(self.build_lib), "equistore/torch")

        os.makedirs(build_dir, exist_ok=True)

        # Tell CMake where to find equistore & torch
        cmake_prefix_path = [
            equistore.core.utils.cmake_prefix_path,
            torch.utils.cmake_prefix_path,
        ]

        cmake_options = [
            "-DCMAKE_BUILD_TYPE=Release",
            f"-DCMAKE_INSTALL_PREFIX={install_dir}",
            f"-DCMAKE_PREFIX_PATH={';'.join(cmake_prefix_path)}",
        ]

        # ==================================================================== #
        # HACK: Torch cmake build system has a hard time finding CuDNN, so we
        # help it by pointing it to the right files

        # First try using the `nvidia.cudnn` package (dependency of torch on PyPI)
        try:
            import nvidia.cudnn

            cudnn_root = os.path.dirname(nvidia.cudnn.__file__)
        except ImportError:
            # Otherwise try to find CuDNN inside PyTorch itself
            cudnn_root = os.path.join(torch.utils.cmake_prefix_path, "..", "..")

            cudnn_version = os.path.join(cudnn_root, "include", "cudnn_version.h")
            if not os.path.exists(cudnn_version):
                # create a minimal cudnn_version.h (with a made-up version),
                # because it is not bundled together with the CuDNN shared
                # library in PyTorch conda distribution, see
                # https://github.com/pytorch/pytorch/issues/47743
                with open(cudnn_version, "w") as fd:
                    fd.write("#define CUDNN_MAJOR 8\n")
                    fd.write("#define CUDNN_MINOR 5\n")
                    fd.write("#define CUDNN_PATCHLEVEL 0\n")

        cmake_options.append(f"-DCUDNN_INCLUDE_DIR={cudnn_root}/include")
        cmake_options.append(f"-DCUDNN_LIBRARY={cudnn_root}/lib")
        # do not warn if the two variables above aren't used
        cmake_options.append("--no-warn-unused-cli")

        # end of HACK
        # ==================================================================== #

        subprocess.run(
            ["cmake", source_dir, *cmake_options],
            cwd=build_dir,
            check=True,
        )
        subprocess.run(
            [
                "cmake",
                "--build",
                build_dir,
                "--config",
                "Release",
                "--target",
                "install",
            ],
            check=True,
        )

        with open(os.path.join(install_dir, "_build_versions.py"), "w") as fd:
            fd.write("# Autogenerated file, do not edit\n\n\n")
            # Store the version of torch used to build the extension, to give a
            # nice error message to the user when trying to load the extension
            # with an older torch version installed
            fd.write(
                "# version of torch used when compiling this package\n"
                f"BUILD_TORCH_VERSION = '{torch.__version__}'\n\n"
            )

            # same for equistore-core
            fd.write(
                "# version of equistore-core used when compiling this package\n"
                f"BUILD_EQUISTORE_CORE_VERSION = '{equistore.core.__version__}'\n"
            )


class bdist_egg_disabled(bdist_egg):
    """Disabled version of bdist_egg

    Prevents setup.py install performing setuptools' default easy_install,
    which it should never ever do.
    """

    def run(self):
        sys.exit(
            "Aborting implicit building of eggs. "
            + "Use `pip install .` or `python setup.py bdist_wheel && pip "
            + "install dist/equistore-*.whl` to install from source."
        )


def git_extra_version():
    """
    If git is available, it is used to check if we are installing a development
    version or a released version (by checking how many commits happened since
    the last tag).
    """

    # Add pre-release info the version
    try:
        tags_list = subprocess.run(
            ["git", "tag"],
            stderr=subprocess.DEVNULL,
            stdout=subprocess.PIPE,
            check=True,
        )
        tags_list = tags_list.stdout.decode("utf8").strip()

        if tags_list == "":
            first_commit = subprocess.run(
                ["git", "rev-list", "--max-parents=0", "HEAD"],
                stderr=subprocess.DEVNULL,
                stdout=subprocess.PIPE,
                check=True,
            )
            reference = first_commit.stdout.decode("utf8").strip()

        else:
            last_tag = subprocess.run(
                ["git", "describe", "--tags", "--abbrev=0"],
                stderr=subprocess.DEVNULL,
                stdout=subprocess.PIPE,
                check=True,
            )

            reference = last_tag.stdout.decode("utf8").strip()

    except Exception:
        reference = ""
        pass

    try:
        n_commits_since_tag = subprocess.run(
            ["git", "rev-list", f"{reference}..HEAD", "--count"],
            stderr=subprocess.DEVNULL,
            stdout=subprocess.PIPE,
            check=True,
        )
        n_commits_since_tag = n_commits_since_tag.stdout.decode("utf8").strip()

        if n_commits_since_tag != 0:
            return ".dev" + n_commits_since_tag
    except Exception:
        pass

    return ""


if __name__ == "__main__":
    with open(os.path.join(ROOT, "AUTHORS")) as fd:
        authors = fd.read().splitlines()

    if authors[0].startswith(".."):
        # handle "raw" symlink files (on Windows or from full repo tarball)
        with open(os.path.join(ROOT, authors[0])) as fd:
            authors = fd.read().splitlines()

    version = "0.1.0" + git_extra_version()

    install_requires = ["torch >= 1.13"]
    if os.path.exists(EQUISTORE_CORE):
        # we are building from a git checkout

        # add a random uuid to the file url to prevent pip from using a cached
        # wheel for equistore-core, and force it to re-build from scratch
        uuid = uuid.uuid4()
        install_requires.append(f"equistore-core @ file://{EQUISTORE_CORE}?{uuid}")
    else:
        # we are building from a sdist/installing from a wheel
        install_requires.append("equistore-core ==0.1.0")

    setup(
        version=version,
        author=", ".join(authors),
        install_requires=install_requires,
        ext_modules=[
            Extension(name="equistore_torch", sources=[]),
        ],
        cmdclass={
            "build_ext": cmake_ext,
            "bdist_egg": bdist_egg if "bdist_egg" in sys.argv else bdist_egg_disabled,
        },
        package_data={
            "equistore-torch": [
                "equistore/torch/bin/*",
                "equistore/torch/lib/*",
                "equistore/torch/include/*",
            ]
        },
    )
