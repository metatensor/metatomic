/* ============    Automatically generated file, DOT NOT EDIT.    ============ *
 *                                                                             *
 *    This file is automatically generated from the aml-storage sources,       *
 *    using cbindgen. If you want to make change to this file (including       *
 *    documentation), make the corresponding changes in the rust sources.      *
 * =========================================================================== */

#ifndef AML_STORAGE_H
#define AML_STORAGE_H

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Status code used when a function succeeded
 */
#define AML_SUCCESS 0

/**
 * Status code used when a function got an invalid parameter
 */
#define AML_INVALID_PARAMETER_ERROR 1

/**
 * Status code used when a memory buffer is too small to fit the requested data
 */
#define AML_BUFFER_SIZE_ERROR 254

/**
 * Status code used when there was an internal error, i.e. there is a bug
 * inside AML itself
 */
#define AML_INTERNAL_ERROR 255

/**
 * The different kinds of labels that can exist on a `aml_descriptor_t`
 */
typedef enum aml_label_kind {
  /**
   * The sample labels, describing different samples in the representation
   */
  AML_SAMPLE_LABELS = 0,
  /**
   * TODO
   */
  AML_SYMMETRIC_LABELS = 1,
  /**
   * The feature labels, describing the features of the representation
   */
  AML_FEATURE_LABELS = 2,
} aml_label_kind;

/**
 * Opaque type representing a `Block`.
 */
typedef struct aml_block_t aml_block_t;

/**
 * Opaque type representing a `Descriptor`.
 */
typedef struct aml_descriptor_t aml_descriptor_t;

/**
 * Status type returned by all functions in the C API.
 *
 * The value 0 (`AML_SUCCESS`) is used to indicate successful operations.
 */
typedef int32_t aml_status_t;

typedef uint64_t aml_data_origin_t;

typedef struct aml_data_storage_t {
  /**
   * User-provided data should be stored here, it will be passed as the
   * first parameter to all function pointers below.
   */
  void *data;
  aml_status_t (*origin)(const void *data, aml_data_origin_t *origin);
  aml_status_t (*set_from_other)(void *data, uint64_t sample, uint64_t feature_start, uint64_t feature_end, const void *other, uint64_t other_sample);
  aml_status_t (*shape)(const void *data, uint64_t *n_samples, uint64_t *n_symmetric, uint64_t *n_features);
  aml_status_t (*reshape)(void *data, uint64_t n_samples, uint64_t n_symmetric, uint64_t n_features);
  aml_status_t (*create)(const void *data, uint64_t n_samples, uint64_t n_symmetric, uint64_t n_features, struct aml_data_storage_t *data_storage);
  void (*destroy)(void *data);
} aml_data_storage_t;

/**
 * Labels representing metadata associated with either samples or features in
 * a given descriptor.
 */
typedef struct aml_labels_t {
  /**
   * Names of the variables composing this set of labels. There are `size`
   * elements in this array, each being a NULL terminated string.
   */
  const char *const *names;
  /**
   * Pointer to the first element of a 2D row-major array of 32-bit signed
   * integer containing the values taken by the different variables in
   * `names`. Each row has `size` elements, and there are `count` rows in
   * total.
   */
  const int32_t *values;
  /**
   * Number of variables/size of a single entry in the set of labels
   */
  uintptr_t size;
  /**
   * Number entries in the set of labels
   */
  uintptr_t count;
} aml_labels_t;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Get the last error message that was created on the current thread.
 *
 * @returns the last error message, as a NULL-terminated string
 */
const char *aml_last_error(void);

aml_status_t aml_register_data_origin(const char *name, aml_data_origin_t *handle);

aml_status_t aml_get_data_origin(aml_data_origin_t origin, char *buffer, uint64_t buffer_size);

struct aml_block_t *aml_block(struct aml_data_storage_t data,
                              struct aml_labels_t samples,
                              struct aml_labels_t symmetric,
                              struct aml_labels_t features);

aml_status_t aml_block_free(struct aml_block_t *block);

aml_status_t aml_block_labels(const struct aml_block_t *block,
                              const char *values_gradients,
                              enum aml_label_kind kind,
                              struct aml_labels_t *labels);

aml_status_t aml_block_data(const struct aml_block_t *block,
                            const char *values_gradients,
                            const struct aml_data_storage_t **data);

aml_status_t aml_block_add_gradient(struct aml_block_t *block,
                                    const char *name,
                                    struct aml_labels_t samples,
                                    struct aml_data_storage_t gradient);

struct aml_descriptor_t *aml_descriptor(struct aml_labels_t sparse_labels,
                                        struct aml_block_t **blocks,
                                        uint64_t blocks_count);

aml_status_t aml_descriptor_free(struct aml_descriptor_t *descriptor);

aml_status_t aml_descriptor_sparse_labels(const struct aml_descriptor_t *descriptor,
                                          struct aml_labels_t *labels);

aml_status_t aml_descriptor_block_by_id(const struct aml_descriptor_t *descriptor,
                                        const struct aml_block_t **block,
                                        uint64_t id);

aml_status_t aml_descriptor_block_selection(const struct aml_descriptor_t *descriptor,
                                            const struct aml_block_t **block,
                                            struct aml_labels_t selection);

aml_status_t aml_descriptor_sparse_to_features(struct aml_descriptor_t *descriptor,
                                               const char *const *variables,
                                               uint64_t variables_count);

aml_status_t aml_descriptor_symmetric_to_features(struct aml_descriptor_t *descriptor);

aml_status_t aml_descriptor_sparse_to_samples(struct aml_descriptor_t *descriptor,
                                              const char *const *variables,
                                              uint64_t variables_count);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* AML_STORAGE_H */
